// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_enums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_enums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/descriptor.pb.h>
#include "steammessages_base.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_enums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_enums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_enums_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_enums_2eproto_metadata_getter(int index);
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

enum EPublishedFileQueryType : int {
  PublishedFileQueryType_RankedByVote = 0,
  PublishedFileQueryType_RankedByPublicationDate = 1,
  PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate = 2,
  PublishedFileQueryType_RankedByTrend = 3,
  PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate = 4,
  PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate = 5,
  PublishedFileQueryType_RankedByNumTimesReported = 6,
  PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate = 7,
  PublishedFileQueryType_NotYetRated = 8,
  PublishedFileQueryType_RankedByTotalUniqueSubscriptions = 9,
  PublishedFileQueryType_RankedByTotalVotesAsc = 10,
  PublishedFileQueryType_RankedByVotesUp = 11,
  PublishedFileQueryType_RankedByTextSearch = 12,
  PublishedFileQueryType_RankedByPlaytimeTrend = 13,
  PublishedFileQueryType_RankedByTotalPlaytime = 14,
  PublishedFileQueryType_RankedByAveragePlaytimeTrend = 15,
  PublishedFileQueryType_RankedByLifetimeAveragePlaytime = 16,
  PublishedFileQueryType_RankedByPlaytimeSessionsTrend = 17,
  PublishedFileQueryType_RankedByLifetimePlaytimeSessions = 18,
  PublishedFileQueryType_RankedByInappropriateContentRating = 19,
  PublishedFileQueryType_RankedByBanContentCheck = 20,
  PublishedFileQueryType_RankedByLastUpdatedDate = 21
};
bool EPublishedFileQueryType_IsValid(int value);
constexpr EPublishedFileQueryType EPublishedFileQueryType_MIN = PublishedFileQueryType_RankedByVote;
constexpr EPublishedFileQueryType EPublishedFileQueryType_MAX = PublishedFileQueryType_RankedByLastUpdatedDate;
constexpr int EPublishedFileQueryType_ARRAYSIZE = EPublishedFileQueryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPublishedFileQueryType_descriptor();
template<typename T>
inline const std::string& EPublishedFileQueryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPublishedFileQueryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPublishedFileQueryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPublishedFileQueryType_descriptor(), enum_t_value);
}
inline bool EPublishedFileQueryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPublishedFileQueryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPublishedFileQueryType>(
    EPublishedFileQueryType_descriptor(), name, value);
}
enum EPublishedFileInappropriateProvider : int {
  EPublishedFileInappropriateProvider_Invalid = 0,
  EPublishedFileInappropriateProvider_Google = 1,
  EPublishedFileInappropriateProvider_Amazon = 2
};
bool EPublishedFileInappropriateProvider_IsValid(int value);
constexpr EPublishedFileInappropriateProvider EPublishedFileInappropriateProvider_MIN = EPublishedFileInappropriateProvider_Invalid;
constexpr EPublishedFileInappropriateProvider EPublishedFileInappropriateProvider_MAX = EPublishedFileInappropriateProvider_Amazon;
constexpr int EPublishedFileInappropriateProvider_ARRAYSIZE = EPublishedFileInappropriateProvider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPublishedFileInappropriateProvider_descriptor();
template<typename T>
inline const std::string& EPublishedFileInappropriateProvider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPublishedFileInappropriateProvider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPublishedFileInappropriateProvider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPublishedFileInappropriateProvider_descriptor(), enum_t_value);
}
inline bool EPublishedFileInappropriateProvider_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPublishedFileInappropriateProvider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPublishedFileInappropriateProvider>(
    EPublishedFileInappropriateProvider_descriptor(), name, value);
}
enum EPublishedFileInappropriateResult : int {
  EPublishedFileInappropriateResult_NotScanned = 0,
  EPublishedFileInappropriateResult_VeryUnlikely = 1,
  EPublishedFileInappropriateResult_Unlikely = 30,
  EPublishedFileInappropriateResult_Possible = 50,
  EPublishedFileInappropriateResult_Likely = 75,
  EPublishedFileInappropriateResult_VeryLikely = 100
};
bool EPublishedFileInappropriateResult_IsValid(int value);
constexpr EPublishedFileInappropriateResult EPublishedFileInappropriateResult_MIN = EPublishedFileInappropriateResult_NotScanned;
constexpr EPublishedFileInappropriateResult EPublishedFileInappropriateResult_MAX = EPublishedFileInappropriateResult_VeryLikely;
constexpr int EPublishedFileInappropriateResult_ARRAYSIZE = EPublishedFileInappropriateResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPublishedFileInappropriateResult_descriptor();
template<typename T>
inline const std::string& EPublishedFileInappropriateResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPublishedFileInappropriateResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPublishedFileInappropriateResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPublishedFileInappropriateResult_descriptor(), enum_t_value);
}
inline bool EPublishedFileInappropriateResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPublishedFileInappropriateResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPublishedFileInappropriateResult>(
    EPublishedFileInappropriateResult_descriptor(), name, value);
}
enum EPersonaStateFlag : int {
  EPersonaStateFlag_HasRichPresence = 1,
  EPersonaStateFlag_InJoinableGame = 2,
  EPersonaStateFlag_Golden = 4,
  EPersonaStateFlag_RemotePlayTogether = 8,
  EPersonaStateFlag_ClientTypeWeb = 256,
  EPersonaStateFlag_ClientTypeMobile = 512,
  EPersonaStateFlag_ClientTypeTenfoot = 1024,
  EPersonaStateFlag_ClientTypeVR = 2048,
  EPersonaStateFlag_LaunchTypeGamepad = 4096,
  EPersonaStateFlag_LaunchTypeCompatTool = 8192
};
bool EPersonaStateFlag_IsValid(int value);
constexpr EPersonaStateFlag EPersonaStateFlag_MIN = EPersonaStateFlag_HasRichPresence;
constexpr EPersonaStateFlag EPersonaStateFlag_MAX = EPersonaStateFlag_LaunchTypeCompatTool;
constexpr int EPersonaStateFlag_ARRAYSIZE = EPersonaStateFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPersonaStateFlag_descriptor();
template<typename T>
inline const std::string& EPersonaStateFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPersonaStateFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPersonaStateFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPersonaStateFlag_descriptor(), enum_t_value);
}
inline bool EPersonaStateFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPersonaStateFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPersonaStateFlag>(
    EPersonaStateFlag_descriptor(), name, value);
}
enum EContentCheckProvider : int {
  EContentCheckProvider_Invalid = 0,
  EContentCheckProvider_Google_DEPRECATED = 1,
  EContentCheckProvider_Amazon = 2,
  EContentCheckProvider_Local = 3,
  EContentCheckProvider_GoogleVertexAI = 4
};
bool EContentCheckProvider_IsValid(int value);
constexpr EContentCheckProvider EContentCheckProvider_MIN = EContentCheckProvider_Invalid;
constexpr EContentCheckProvider EContentCheckProvider_MAX = EContentCheckProvider_GoogleVertexAI;
constexpr int EContentCheckProvider_ARRAYSIZE = EContentCheckProvider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EContentCheckProvider_descriptor();
template<typename T>
inline const std::string& EContentCheckProvider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EContentCheckProvider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EContentCheckProvider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EContentCheckProvider_descriptor(), enum_t_value);
}
inline bool EContentCheckProvider_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EContentCheckProvider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EContentCheckProvider>(
    EContentCheckProvider_descriptor(), name, value);
}
enum EProfileCustomizationType : int {
  EProfileCustomizationTypeInvalid = 0,
  EProfileCustomizationTypeRareAchievementShowcase = 1,
  EProfileCustomizationTypeGameCollector = 2,
  EProfileCustomizationTypeItemShowcase = 3,
  EProfileCustomizationTypeTradeShowcase = 4,
  EProfileCustomizationTypeBadges = 5,
  EProfileCustomizationTypeFavoriteGame = 6,
  EProfileCustomizationTypeScreenshotShowcase = 7,
  EProfileCustomizationTypeCustomText = 8,
  EProfileCustomizationTypeFavoriteGroup = 9,
  EProfileCustomizationTypeRecommendation = 10,
  EProfileCustomizationTypeWorkshopItem = 11,
  EProfileCustomizationTypeMyWorkshop = 12,
  EProfileCustomizationTypeArtworkShowcase = 13,
  EProfileCustomizationTypeVideoShowcase = 14,
  EProfileCustomizationTypeGuides = 15,
  EProfileCustomizationTypeMyGuides = 16,
  EProfileCustomizationTypeAchievements = 17,
  EProfileCustomizationTypeGreenlight = 18,
  EProfileCustomizationTypeMyGreenlight = 19,
  EProfileCustomizationTypeSalien = 20,
  EProfileCustomizationTypeLoyaltyRewardReactions = 21,
  EProfileCustomizationTypeSingleArtworkShowcase = 22,
  EProfileCustomizationTypeAchievementsCompletionist = 23,
  EProfileCustomizationTypeReplay = 24
};
bool EProfileCustomizationType_IsValid(int value);
constexpr EProfileCustomizationType EProfileCustomizationType_MIN = EProfileCustomizationTypeInvalid;
constexpr EProfileCustomizationType EProfileCustomizationType_MAX = EProfileCustomizationTypeReplay;
constexpr int EProfileCustomizationType_ARRAYSIZE = EProfileCustomizationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EProfileCustomizationType_descriptor();
template<typename T>
inline const std::string& EProfileCustomizationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EProfileCustomizationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EProfileCustomizationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EProfileCustomizationType_descriptor(), enum_t_value);
}
inline bool EProfileCustomizationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EProfileCustomizationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EProfileCustomizationType>(
    EProfileCustomizationType_descriptor(), name, value);
}
enum EPublishedFileStorageSystem : int {
  EPublishedFileStorageSystemInvalid = 0,
  EPublishedFileStorageSystemLegacyCloud = 1,
  EPublishedFileStorageSystemDepot = 2,
  EPublishedFileStorageSystemUGCCloud = 3
};
bool EPublishedFileStorageSystem_IsValid(int value);
constexpr EPublishedFileStorageSystem EPublishedFileStorageSystem_MIN = EPublishedFileStorageSystemInvalid;
constexpr EPublishedFileStorageSystem EPublishedFileStorageSystem_MAX = EPublishedFileStorageSystemUGCCloud;
constexpr int EPublishedFileStorageSystem_ARRAYSIZE = EPublishedFileStorageSystem_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPublishedFileStorageSystem_descriptor();
template<typename T>
inline const std::string& EPublishedFileStorageSystem_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPublishedFileStorageSystem>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPublishedFileStorageSystem_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPublishedFileStorageSystem_descriptor(), enum_t_value);
}
inline bool EPublishedFileStorageSystem_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPublishedFileStorageSystem* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPublishedFileStorageSystem>(
    EPublishedFileStorageSystem_descriptor(), name, value);
}
enum ECloudStoragePersistState : int {
  ECloudStoragePersistStatePersisted = 0,
  ECloudStoragePersistStateForgotten = 1,
  ECloudStoragePersistStateDeleted = 2
};
bool ECloudStoragePersistState_IsValid(int value);
constexpr ECloudStoragePersistState ECloudStoragePersistState_MIN = ECloudStoragePersistStatePersisted;
constexpr ECloudStoragePersistState ECloudStoragePersistState_MAX = ECloudStoragePersistStateDeleted;
constexpr int ECloudStoragePersistState_ARRAYSIZE = ECloudStoragePersistState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECloudStoragePersistState_descriptor();
template<typename T>
inline const std::string& ECloudStoragePersistState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECloudStoragePersistState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECloudStoragePersistState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECloudStoragePersistState_descriptor(), enum_t_value);
}
inline bool ECloudStoragePersistState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECloudStoragePersistState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECloudStoragePersistState>(
    ECloudStoragePersistState_descriptor(), name, value);
}
enum ESDCardFormatStage : int {
  ESDCardFormatStage_Invalid = 0,
  ESDCardFormatStage_Starting = 1,
  ESDCardFormatStage_Testing = 2,
  ESDCardFormatStage_Rescuing = 3,
  ESDCardFormatStage_Formatting = 4,
  ESDCardFormatStage_Finalizing = 5
};
bool ESDCardFormatStage_IsValid(int value);
constexpr ESDCardFormatStage ESDCardFormatStage_MIN = ESDCardFormatStage_Invalid;
constexpr ESDCardFormatStage ESDCardFormatStage_MAX = ESDCardFormatStage_Finalizing;
constexpr int ESDCardFormatStage_ARRAYSIZE = ESDCardFormatStage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESDCardFormatStage_descriptor();
template<typename T>
inline const std::string& ESDCardFormatStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESDCardFormatStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESDCardFormatStage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESDCardFormatStage_descriptor(), enum_t_value);
}
inline bool ESDCardFormatStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESDCardFormatStage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESDCardFormatStage>(
    ESDCardFormatStage_descriptor(), name, value);
}
enum EStorageFormatStage : int {
  EStorageFormatStage_Invalid = 0,
  EStorageFormatStage_NotRunning = 1,
  EStorageFormatStage_Starting = 2,
  EStorageFormatStage_Testing = 3,
  EStorageFormatStage_Rescuing = 4,
  EStorageFormatStage_Formatting = 5,
  EStorageFormatStage_Finalizing = 6
};
bool EStorageFormatStage_IsValid(int value);
constexpr EStorageFormatStage EStorageFormatStage_MIN = EStorageFormatStage_Invalid;
constexpr EStorageFormatStage EStorageFormatStage_MAX = EStorageFormatStage_Finalizing;
constexpr int EStorageFormatStage_ARRAYSIZE = EStorageFormatStage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStorageFormatStage_descriptor();
template<typename T>
inline const std::string& EStorageFormatStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStorageFormatStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStorageFormatStage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStorageFormatStage_descriptor(), enum_t_value);
}
inline bool EStorageFormatStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStorageFormatStage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStorageFormatStage>(
    EStorageFormatStage_descriptor(), name, value);
}
enum ESystemFanControlMode : int {
  SystemFanControlMode_Invalid = 0,
  SystemFanControlMode_Disabled = 1,
  SystemFanControlMode_Default = 2
};
bool ESystemFanControlMode_IsValid(int value);
constexpr ESystemFanControlMode ESystemFanControlMode_MIN = SystemFanControlMode_Invalid;
constexpr ESystemFanControlMode ESystemFanControlMode_MAX = SystemFanControlMode_Default;
constexpr int ESystemFanControlMode_ARRAYSIZE = ESystemFanControlMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemFanControlMode_descriptor();
template<typename T>
inline const std::string& ESystemFanControlMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemFanControlMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemFanControlMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemFanControlMode_descriptor(), enum_t_value);
}
inline bool ESystemFanControlMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemFanControlMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemFanControlMode>(
    ESystemFanControlMode_descriptor(), name, value);
}
enum EStartupMovieVariant : int {
  EStartupMovieVariant_Invalid = 0,
  EStartupMovieVariant_Default = 1,
  EStartupMovieVariant_Orange = 2
};
bool EStartupMovieVariant_IsValid(int value);
constexpr EStartupMovieVariant EStartupMovieVariant_MIN = EStartupMovieVariant_Invalid;
constexpr EStartupMovieVariant EStartupMovieVariant_MAX = EStartupMovieVariant_Orange;
constexpr int EStartupMovieVariant_ARRAYSIZE = EStartupMovieVariant_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStartupMovieVariant_descriptor();
template<typename T>
inline const std::string& EStartupMovieVariant_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStartupMovieVariant>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStartupMovieVariant_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStartupMovieVariant_descriptor(), enum_t_value);
}
inline bool EStartupMovieVariant_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStartupMovieVariant* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStartupMovieVariant>(
    EStartupMovieVariant_descriptor(), name, value);
}
enum EColorGamutLabelSet : int {
  ColorGamutLabelSet_Default = 0,
  ColorGamutLabelSet_sRGB_Native = 1,
  ColorGamutLabelSet_Native_sRGB_Boosted = 2
};
bool EColorGamutLabelSet_IsValid(int value);
constexpr EColorGamutLabelSet EColorGamutLabelSet_MIN = ColorGamutLabelSet_Default;
constexpr EColorGamutLabelSet EColorGamutLabelSet_MAX = ColorGamutLabelSet_Native_sRGB_Boosted;
constexpr int EColorGamutLabelSet_ARRAYSIZE = EColorGamutLabelSet_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EColorGamutLabelSet_descriptor();
template<typename T>
inline const std::string& EColorGamutLabelSet_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EColorGamutLabelSet>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EColorGamutLabelSet_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EColorGamutLabelSet_descriptor(), enum_t_value);
}
inline bool EColorGamutLabelSet_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EColorGamutLabelSet* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EColorGamutLabelSet>(
    EColorGamutLabelSet_descriptor(), name, value);
}
enum EBluetoothDeviceType : int {
  BluetoothDeviceType_Invalid = 0,
  BluetoothDeviceType_Unknown = 1,
  BluetoothDeviceType_Phone = 2,
  BluetoothDeviceType_Computer = 3,
  BluetoothDeviceType_Headset = 4,
  BluetoothDeviceType_Headphones = 5,
  BluetoothDeviceType_Speakers = 6,
  BluetoothDeviceType_OtherAudio = 7,
  BluetoothDeviceType_Mouse = 8,
  BluetoothDeviceType_Joystick = 9,
  BluetoothDeviceType_Gamepad = 10,
  BluetoothDeviceType_Keyboard = 11
};
bool EBluetoothDeviceType_IsValid(int value);
constexpr EBluetoothDeviceType EBluetoothDeviceType_MIN = BluetoothDeviceType_Invalid;
constexpr EBluetoothDeviceType EBluetoothDeviceType_MAX = BluetoothDeviceType_Keyboard;
constexpr int EBluetoothDeviceType_ARRAYSIZE = EBluetoothDeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBluetoothDeviceType_descriptor();
template<typename T>
inline const std::string& EBluetoothDeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBluetoothDeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBluetoothDeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBluetoothDeviceType_descriptor(), enum_t_value);
}
inline bool EBluetoothDeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBluetoothDeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBluetoothDeviceType>(
    EBluetoothDeviceType_descriptor(), name, value);
}
enum ESystemAudioDirection : int {
  SystemAudioDirection_Invalid = 0,
  SystemAudioDirection_Input = 1,
  SystemAudioDirection_Output = 2
};
bool ESystemAudioDirection_IsValid(int value);
constexpr ESystemAudioDirection ESystemAudioDirection_MIN = SystemAudioDirection_Invalid;
constexpr ESystemAudioDirection ESystemAudioDirection_MAX = SystemAudioDirection_Output;
constexpr int ESystemAudioDirection_ARRAYSIZE = ESystemAudioDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemAudioDirection_descriptor();
template<typename T>
inline const std::string& ESystemAudioDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemAudioDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemAudioDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemAudioDirection_descriptor(), enum_t_value);
}
inline bool ESystemAudioDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemAudioDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemAudioDirection>(
    ESystemAudioDirection_descriptor(), name, value);
}
enum ESystemAudioChannel : int {
  SystemAudioChannel_Invalid = 0,
  SystemAudioChannel_Aggregated = 1,
  SystemAudioChannel_FrontLeft = 2,
  SystemAudioChannel_FrontRight = 3,
  SystemAudioChannel_LFE = 4,
  SystemAudioChannel_BackLeft = 5,
  SystemAudioChannel_BackRight = 6,
  SystemAudioChannel_FrontCenter = 7,
  SystemAudioChannel_Unknown = 8,
  SystemAudioChannel_Mono = 9
};
bool ESystemAudioChannel_IsValid(int value);
constexpr ESystemAudioChannel ESystemAudioChannel_MIN = SystemAudioChannel_Invalid;
constexpr ESystemAudioChannel ESystemAudioChannel_MAX = SystemAudioChannel_Mono;
constexpr int ESystemAudioChannel_ARRAYSIZE = ESystemAudioChannel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemAudioChannel_descriptor();
template<typename T>
inline const std::string& ESystemAudioChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemAudioChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemAudioChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemAudioChannel_descriptor(), enum_t_value);
}
inline bool ESystemAudioChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemAudioChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemAudioChannel>(
    ESystemAudioChannel_descriptor(), name, value);
}
enum ESystemAudioPortType : int {
  SystemAudioPortType_Invalid = 0,
  SystemAudioPortType_Unknown = 1,
  SystemAudioPortType_Audio32f = 2,
  SystemAudioPortType_Midi8b = 3,
  SystemAudioPortType_Video32RGBA = 4
};
bool ESystemAudioPortType_IsValid(int value);
constexpr ESystemAudioPortType ESystemAudioPortType_MIN = SystemAudioPortType_Invalid;
constexpr ESystemAudioPortType ESystemAudioPortType_MAX = SystemAudioPortType_Video32RGBA;
constexpr int ESystemAudioPortType_ARRAYSIZE = ESystemAudioPortType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemAudioPortType_descriptor();
template<typename T>
inline const std::string& ESystemAudioPortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemAudioPortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemAudioPortType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemAudioPortType_descriptor(), enum_t_value);
}
inline bool ESystemAudioPortType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemAudioPortType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemAudioPortType>(
    ESystemAudioPortType_descriptor(), name, value);
}
enum ESystemAudioPortDirection : int {
  SystemAudioPortDirection_Invalid = 0,
  SystemAudioPortDirection_Input = 1,
  SystemAudioPortDirection_Output = 2
};
bool ESystemAudioPortDirection_IsValid(int value);
constexpr ESystemAudioPortDirection ESystemAudioPortDirection_MIN = SystemAudioPortDirection_Invalid;
constexpr ESystemAudioPortDirection ESystemAudioPortDirection_MAX = SystemAudioPortDirection_Output;
constexpr int ESystemAudioPortDirection_ARRAYSIZE = ESystemAudioPortDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemAudioPortDirection_descriptor();
template<typename T>
inline const std::string& ESystemAudioPortDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemAudioPortDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemAudioPortDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemAudioPortDirection_descriptor(), enum_t_value);
}
inline bool ESystemAudioPortDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemAudioPortDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemAudioPortDirection>(
    ESystemAudioPortDirection_descriptor(), name, value);
}
enum ESystemServiceState : int {
  ESystemServiceState_Unavailable = 0,
  ESystemServiceState_Disabled = 1,
  ESystemServiceState_Enabled = 2
};
bool ESystemServiceState_IsValid(int value);
constexpr ESystemServiceState ESystemServiceState_MIN = ESystemServiceState_Unavailable;
constexpr ESystemServiceState ESystemServiceState_MAX = ESystemServiceState_Enabled;
constexpr int ESystemServiceState_ARRAYSIZE = ESystemServiceState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemServiceState_descriptor();
template<typename T>
inline const std::string& ESystemServiceState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemServiceState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemServiceState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemServiceState_descriptor(), enum_t_value);
}
inline bool ESystemServiceState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemServiceState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemServiceState>(
    ESystemServiceState_descriptor(), name, value);
}
enum EGraphicsPerfOverlayLevel : int {
  EGraphicsPerfOverlayLevel_Hidden = 0,
  EGraphicsPerfOverlayLevel_Basic = 1,
  EGraphicsPerfOverlayLevel_Medium = 2,
  EGraphicsPerfOverlayLevel_Full = 3,
  EGraphicsPerfOverlayLevel_Minimal = 4
};
bool EGraphicsPerfOverlayLevel_IsValid(int value);
constexpr EGraphicsPerfOverlayLevel EGraphicsPerfOverlayLevel_MIN = EGraphicsPerfOverlayLevel_Hidden;
constexpr EGraphicsPerfOverlayLevel EGraphicsPerfOverlayLevel_MAX = EGraphicsPerfOverlayLevel_Minimal;
constexpr int EGraphicsPerfOverlayLevel_ARRAYSIZE = EGraphicsPerfOverlayLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGraphicsPerfOverlayLevel_descriptor();
template<typename T>
inline const std::string& EGraphicsPerfOverlayLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGraphicsPerfOverlayLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGraphicsPerfOverlayLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGraphicsPerfOverlayLevel_descriptor(), enum_t_value);
}
inline bool EGraphicsPerfOverlayLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGraphicsPerfOverlayLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGraphicsPerfOverlayLevel>(
    EGraphicsPerfOverlayLevel_descriptor(), name, value);
}
enum EGPUPerformanceLevel : int {
  EGPUPerformanceLevel_Invalid = 0,
  EGPUPerformanceLevel_Auto = 1,
  EGPUPerformanceLevel_Manual = 2,
  EGPUPerformanceLevel_Low = 3,
  EGPUPerformanceLevel_High = 4,
  EGPUPerformanceLevel_Profiling = 5
};
bool EGPUPerformanceLevel_IsValid(int value);
constexpr EGPUPerformanceLevel EGPUPerformanceLevel_MIN = EGPUPerformanceLevel_Invalid;
constexpr EGPUPerformanceLevel EGPUPerformanceLevel_MAX = EGPUPerformanceLevel_Profiling;
constexpr int EGPUPerformanceLevel_ARRAYSIZE = EGPUPerformanceLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGPUPerformanceLevel_descriptor();
template<typename T>
inline const std::string& EGPUPerformanceLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGPUPerformanceLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGPUPerformanceLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGPUPerformanceLevel_descriptor(), enum_t_value);
}
inline bool EGPUPerformanceLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGPUPerformanceLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGPUPerformanceLevel>(
    EGPUPerformanceLevel_descriptor(), name, value);
}
enum EScalingFilter : int {
  EScalingFilter_Invalid = 0,
  EScalingFilter_FSR = 1,
  EScalingFilter_Nearest = 2,
  EScalingFilter_Integer = 3,
  EScalingFilter_Linear = 4,
  EScalingFilter_NIS = 5
};
bool EScalingFilter_IsValid(int value);
constexpr EScalingFilter EScalingFilter_MIN = EScalingFilter_Invalid;
constexpr EScalingFilter EScalingFilter_MAX = EScalingFilter_NIS;
constexpr int EScalingFilter_ARRAYSIZE = EScalingFilter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EScalingFilter_descriptor();
template<typename T>
inline const std::string& EScalingFilter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EScalingFilter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EScalingFilter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EScalingFilter_descriptor(), enum_t_value);
}
inline bool EScalingFilter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EScalingFilter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EScalingFilter>(
    EScalingFilter_descriptor(), name, value);
}
enum ESplitScalingFilter : int {
  ESplitScalingFilter_Invalid = 0,
  ESplitScalingFilter_Linear = 1,
  ESplitScalingFilter_Nearest = 2,
  ESplitScalingFilter_FSR = 3,
  ESplitScalingFilter_NIS = 4
};
bool ESplitScalingFilter_IsValid(int value);
constexpr ESplitScalingFilter ESplitScalingFilter_MIN = ESplitScalingFilter_Invalid;
constexpr ESplitScalingFilter ESplitScalingFilter_MAX = ESplitScalingFilter_NIS;
constexpr int ESplitScalingFilter_ARRAYSIZE = ESplitScalingFilter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESplitScalingFilter_descriptor();
template<typename T>
inline const std::string& ESplitScalingFilter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESplitScalingFilter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESplitScalingFilter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESplitScalingFilter_descriptor(), enum_t_value);
}
inline bool ESplitScalingFilter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESplitScalingFilter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESplitScalingFilter>(
    ESplitScalingFilter_descriptor(), name, value);
}
enum ESplitScalingScaler : int {
  ESplitScalingScaler_Invalid = 0,
  ESplitScalingScaler_Auto = 1,
  ESplitScalingScaler_Integer = 2,
  ESplitScalingScaler_Fit = 3,
  ESplitScalingScaler_Fill = 4,
  ESplitScalingScaler_Stretch = 5
};
bool ESplitScalingScaler_IsValid(int value);
constexpr ESplitScalingScaler ESplitScalingScaler_MIN = ESplitScalingScaler_Invalid;
constexpr ESplitScalingScaler ESplitScalingScaler_MAX = ESplitScalingScaler_Stretch;
constexpr int ESplitScalingScaler_ARRAYSIZE = ESplitScalingScaler_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESplitScalingScaler_descriptor();
template<typename T>
inline const std::string& ESplitScalingScaler_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESplitScalingScaler>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESplitScalingScaler_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESplitScalingScaler_descriptor(), enum_t_value);
}
inline bool ESplitScalingScaler_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESplitScalingScaler* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESplitScalingScaler>(
    ESplitScalingScaler_descriptor(), name, value);
}
enum EGamescopeBlurMode : int {
  EGamescopeBlurMode_Disabled = 0,
  EGamescopeBlurMode_IfOccluded = 1,
  EGamescopeBlurMode_Always = 2
};
bool EGamescopeBlurMode_IsValid(int value);
constexpr EGamescopeBlurMode EGamescopeBlurMode_MIN = EGamescopeBlurMode_Disabled;
constexpr EGamescopeBlurMode EGamescopeBlurMode_MAX = EGamescopeBlurMode_Always;
constexpr int EGamescopeBlurMode_ARRAYSIZE = EGamescopeBlurMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGamescopeBlurMode_descriptor();
template<typename T>
inline const std::string& EGamescopeBlurMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGamescopeBlurMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGamescopeBlurMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGamescopeBlurMode_descriptor(), enum_t_value);
}
inline bool EGamescopeBlurMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGamescopeBlurMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGamescopeBlurMode>(
    EGamescopeBlurMode_descriptor(), name, value);
}
enum ESLSHelper : int {
  ESLSHelper_Invalid = 0,
  ESLSHelper_Minidump = 1,
  ESLSHelper_Kdump = 2,
  ESLSHelper_Journal = 3,
  ESLSHelper_Gpu = 4,
  ESLSHelper_SystemInfo = 5
};
bool ESLSHelper_IsValid(int value);
constexpr ESLSHelper ESLSHelper_MIN = ESLSHelper_Invalid;
constexpr ESLSHelper ESLSHelper_MAX = ESLSHelper_SystemInfo;
constexpr int ESLSHelper_ARRAYSIZE = ESLSHelper_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESLSHelper_descriptor();
template<typename T>
inline const std::string& ESLSHelper_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESLSHelper>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESLSHelper_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESLSHelper_descriptor(), enum_t_value);
}
inline bool ESLSHelper_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESLSHelper* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESLSHelper>(
    ESLSHelper_descriptor(), name, value);
}
enum EHDRVisualization : int {
  EHDRVisualization_None = 0,
  EHDRVisualization_Heatmap = 1,
  EHDRVisualization_Analysis = 2,
  EHDRVisualization_HeatmapExtended = 3,
  EHDRVisualization_HeatmapClassic = 4
};
bool EHDRVisualization_IsValid(int value);
constexpr EHDRVisualization EHDRVisualization_MIN = EHDRVisualization_None;
constexpr EHDRVisualization EHDRVisualization_MAX = EHDRVisualization_HeatmapClassic;
constexpr int EHDRVisualization_ARRAYSIZE = EHDRVisualization_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EHDRVisualization_descriptor();
template<typename T>
inline const std::string& EHDRVisualization_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EHDRVisualization>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EHDRVisualization_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EHDRVisualization_descriptor(), enum_t_value);
}
inline bool EHDRVisualization_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EHDRVisualization* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EHDRVisualization>(
    EHDRVisualization_descriptor(), name, value);
}
enum EHDRToneMapOperator : int {
  EHDRToneMapOperator_Invalid = 0,
  EHDRToneMapOperator_Uncharted = 1,
  EHDRToneMapOperator_Reinhard = 2
};
bool EHDRToneMapOperator_IsValid(int value);
constexpr EHDRToneMapOperator EHDRToneMapOperator_MIN = EHDRToneMapOperator_Invalid;
constexpr EHDRToneMapOperator EHDRToneMapOperator_MAX = EHDRToneMapOperator_Reinhard;
constexpr int EHDRToneMapOperator_ARRAYSIZE = EHDRToneMapOperator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EHDRToneMapOperator_descriptor();
template<typename T>
inline const std::string& EHDRToneMapOperator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EHDRToneMapOperator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EHDRToneMapOperator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EHDRToneMapOperator_descriptor(), enum_t_value);
}
inline bool EHDRToneMapOperator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EHDRToneMapOperator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EHDRToneMapOperator>(
    EHDRToneMapOperator_descriptor(), name, value);
}
enum ECPUGovernor : int {
  ECPUGovernor_Invalid = 0,
  ECPUGovernor_Perf = 1,
  ECPUGovernor_Powersave = 2,
  ECPUGovernor_Manual = 3
};
bool ECPUGovernor_IsValid(int value);
constexpr ECPUGovernor ECPUGovernor_MIN = ECPUGovernor_Invalid;
constexpr ECPUGovernor ECPUGovernor_MAX = ECPUGovernor_Manual;
constexpr int ECPUGovernor_ARRAYSIZE = ECPUGovernor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECPUGovernor_descriptor();
template<typename T>
inline const std::string& ECPUGovernor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECPUGovernor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECPUGovernor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECPUGovernor_descriptor(), enum_t_value);
}
inline bool ECPUGovernor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECPUGovernor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECPUGovernor>(
    ECPUGovernor_descriptor(), name, value);
}
enum EUpdaterType : int {
  EUpdaterType_Invalid = 0,
  EUpdaterType_Client = 1,
  EUpdaterType_OS = 2,
  EUpdaterType_BIOS = 3,
  EUpdaterType_Aggregated = 4,
  EUpdaterType_Test1 = 5,
  EUpdaterType_Test2 = 6,
  EUpdaterType_Dummy = 7
};
bool EUpdaterType_IsValid(int value);
constexpr EUpdaterType EUpdaterType_MIN = EUpdaterType_Invalid;
constexpr EUpdaterType EUpdaterType_MAX = EUpdaterType_Dummy;
constexpr int EUpdaterType_ARRAYSIZE = EUpdaterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EUpdaterType_descriptor();
template<typename T>
inline const std::string& EUpdaterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EUpdaterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EUpdaterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EUpdaterType_descriptor(), enum_t_value);
}
inline bool EUpdaterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EUpdaterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EUpdaterType>(
    EUpdaterType_descriptor(), name, value);
}
enum EUpdaterState : int {
  EUpdaterState_Invalid = 0,
  EUpdaterState_UpToDate = 2,
  EUpdaterState_Checking = 3,
  EUpdaterState_Available = 4,
  EUpdaterState_Applying = 5,
  EUpdaterState_ClientRestartPending = 6,
  EUpdaterState_SystemRestartPending = 7
};
bool EUpdaterState_IsValid(int value);
constexpr EUpdaterState EUpdaterState_MIN = EUpdaterState_Invalid;
constexpr EUpdaterState EUpdaterState_MAX = EUpdaterState_SystemRestartPending;
constexpr int EUpdaterState_ARRAYSIZE = EUpdaterState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EUpdaterState_descriptor();
template<typename T>
inline const std::string& EUpdaterState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EUpdaterState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EUpdaterState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EUpdaterState_descriptor(), enum_t_value);
}
inline bool EUpdaterState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EUpdaterState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EUpdaterState>(
    EUpdaterState_descriptor(), name, value);
}
enum EStorageBlockContentType : int {
  EStorageBlockContentType_Invalid = 0,
  EStorageBlockContentType_Unknown = 1,
  EStorageBlockContentType_FileSystem = 2,
  EStorageBlockContentType_Crypto = 3,
  EStorageBlockContentType_Raid = 4
};
bool EStorageBlockContentType_IsValid(int value);
constexpr EStorageBlockContentType EStorageBlockContentType_MIN = EStorageBlockContentType_Invalid;
constexpr EStorageBlockContentType EStorageBlockContentType_MAX = EStorageBlockContentType_Raid;
constexpr int EStorageBlockContentType_ARRAYSIZE = EStorageBlockContentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStorageBlockContentType_descriptor();
template<typename T>
inline const std::string& EStorageBlockContentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStorageBlockContentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStorageBlockContentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStorageBlockContentType_descriptor(), enum_t_value);
}
inline bool EStorageBlockContentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStorageBlockContentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStorageBlockContentType>(
    EStorageBlockContentType_descriptor(), name, value);
}
enum EStorageBlockFileSystemType : int {
  EStorageBlockFileSystemType_Invalid = 0,
  EStorageBlockFileSystemType_Unknown = 1,
  EStorageBlockFileSystemType_VFat = 2,
  EStorageBlockFileSystemType_Ext4 = 3
};
bool EStorageBlockFileSystemType_IsValid(int value);
constexpr EStorageBlockFileSystemType EStorageBlockFileSystemType_MIN = EStorageBlockFileSystemType_Invalid;
constexpr EStorageBlockFileSystemType EStorageBlockFileSystemType_MAX = EStorageBlockFileSystemType_Ext4;
constexpr int EStorageBlockFileSystemType_ARRAYSIZE = EStorageBlockFileSystemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStorageBlockFileSystemType_descriptor();
template<typename T>
inline const std::string& EStorageBlockFileSystemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStorageBlockFileSystemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStorageBlockFileSystemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStorageBlockFileSystemType_descriptor(), enum_t_value);
}
inline bool EStorageBlockFileSystemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStorageBlockFileSystemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStorageBlockFileSystemType>(
    EStorageBlockFileSystemType_descriptor(), name, value);
}
enum EStorageDriveMediaType : int {
  EStorageDriveMediaType_Invalid = 0,
  EStorageDriveMediaType_Unknown = 1,
  EStorageDriveMediaType_HDD = 2,
  EStorageDriveMediaType_SSD = 3,
  EStorageDriveMediaType_Removable = 4
};
bool EStorageDriveMediaType_IsValid(int value);
constexpr EStorageDriveMediaType EStorageDriveMediaType_MIN = EStorageDriveMediaType_Invalid;
constexpr EStorageDriveMediaType EStorageDriveMediaType_MAX = EStorageDriveMediaType_Removable;
constexpr int EStorageDriveMediaType_ARRAYSIZE = EStorageDriveMediaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStorageDriveMediaType_descriptor();
template<typename T>
inline const std::string& EStorageDriveMediaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStorageDriveMediaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStorageDriveMediaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStorageDriveMediaType_descriptor(), enum_t_value);
}
inline bool EStorageDriveMediaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStorageDriveMediaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStorageDriveMediaType>(
    EStorageDriveMediaType_descriptor(), name, value);
}
enum ESystemDisplayCompatibilityMode : int {
  ESystemDisplayCompatibilityMode_Invalid = 0,
  ESystemDisplayCompatibilityMode_None = 1,
  ESystemDisplayCompatibilityMode_MinimalBandwith = 2
};
bool ESystemDisplayCompatibilityMode_IsValid(int value);
constexpr ESystemDisplayCompatibilityMode ESystemDisplayCompatibilityMode_MIN = ESystemDisplayCompatibilityMode_Invalid;
constexpr ESystemDisplayCompatibilityMode ESystemDisplayCompatibilityMode_MAX = ESystemDisplayCompatibilityMode_MinimalBandwith;
constexpr int ESystemDisplayCompatibilityMode_ARRAYSIZE = ESystemDisplayCompatibilityMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemDisplayCompatibilityMode_descriptor();
template<typename T>
inline const std::string& ESystemDisplayCompatibilityMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemDisplayCompatibilityMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemDisplayCompatibilityMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemDisplayCompatibilityMode_descriptor(), enum_t_value);
}
inline bool ESystemDisplayCompatibilityMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemDisplayCompatibilityMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemDisplayCompatibilityMode>(
    ESystemDisplayCompatibilityMode_descriptor(), name, value);
}
enum ESteamDeckCompatibilityCategory : int {
  ESteamDeckCompatibilityCategory_Unknown = 0,
  ESteamDeckCompatibilityCategory_Unsupported = 1,
  ESteamDeckCompatibilityCategory_Playable = 2,
  ESteamDeckCompatibilityCategory_Verified = 3
};
bool ESteamDeckCompatibilityCategory_IsValid(int value);
constexpr ESteamDeckCompatibilityCategory ESteamDeckCompatibilityCategory_MIN = ESteamDeckCompatibilityCategory_Unknown;
constexpr ESteamDeckCompatibilityCategory ESteamDeckCompatibilityCategory_MAX = ESteamDeckCompatibilityCategory_Verified;
constexpr int ESteamDeckCompatibilityCategory_ARRAYSIZE = ESteamDeckCompatibilityCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESteamDeckCompatibilityCategory_descriptor();
template<typename T>
inline const std::string& ESteamDeckCompatibilityCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESteamDeckCompatibilityCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESteamDeckCompatibilityCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESteamDeckCompatibilityCategory_descriptor(), enum_t_value);
}
inline bool ESteamDeckCompatibilityCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESteamDeckCompatibilityCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESteamDeckCompatibilityCategory>(
    ESteamDeckCompatibilityCategory_descriptor(), name, value);
}
enum ESteamDeckCompatibilityResultDisplayType : int {
  ESteamDeckCompatibilityResultDisplayType_Invisible = 0,
  ESteamDeckCompatibilityResultDisplayType_Informational = 1,
  ESteamDeckCompatibilityResultDisplayType_Unsupported = 2,
  ESteamDeckCompatibilityResultDisplayType_Playable = 3,
  ESteamDeckCompatibilityResultDisplayType_Verified = 4
};
bool ESteamDeckCompatibilityResultDisplayType_IsValid(int value);
constexpr ESteamDeckCompatibilityResultDisplayType ESteamDeckCompatibilityResultDisplayType_MIN = ESteamDeckCompatibilityResultDisplayType_Invisible;
constexpr ESteamDeckCompatibilityResultDisplayType ESteamDeckCompatibilityResultDisplayType_MAX = ESteamDeckCompatibilityResultDisplayType_Verified;
constexpr int ESteamDeckCompatibilityResultDisplayType_ARRAYSIZE = ESteamDeckCompatibilityResultDisplayType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESteamDeckCompatibilityResultDisplayType_descriptor();
template<typename T>
inline const std::string& ESteamDeckCompatibilityResultDisplayType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESteamDeckCompatibilityResultDisplayType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESteamDeckCompatibilityResultDisplayType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESteamDeckCompatibilityResultDisplayType_descriptor(), enum_t_value);
}
inline bool ESteamDeckCompatibilityResultDisplayType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESteamDeckCompatibilityResultDisplayType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESteamDeckCompatibilityResultDisplayType>(
    ESteamDeckCompatibilityResultDisplayType_descriptor(), name, value);
}
enum EACState : int {
  EACState_Unknown = 0,
  EACState_Disconnected = 1,
  EACState_Connected = 2,
  EACState_ConnectedSlow = 3
};
bool EACState_IsValid(int value);
constexpr EACState EACState_MIN = EACState_Unknown;
constexpr EACState EACState_MAX = EACState_ConnectedSlow;
constexpr int EACState_ARRAYSIZE = EACState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EACState_descriptor();
template<typename T>
inline const std::string& EACState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EACState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EACState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EACState_descriptor(), enum_t_value);
}
inline bool EACState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EACState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EACState>(
    EACState_descriptor(), name, value);
}
enum EBatteryState : int {
  EBatteryState_Unknown = 0,
  EBatteryState_Discharging = 1,
  EBatteryState_Charging = 2,
  EBatteryState_Full = 3
};
bool EBatteryState_IsValid(int value);
constexpr EBatteryState EBatteryState_MIN = EBatteryState_Unknown;
constexpr EBatteryState EBatteryState_MAX = EBatteryState_Full;
constexpr int EBatteryState_ARRAYSIZE = EBatteryState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBatteryState_descriptor();
template<typename T>
inline const std::string& EBatteryState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBatteryState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBatteryState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBatteryState_descriptor(), enum_t_value);
}
inline bool EBatteryState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBatteryState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBatteryState>(
    EBatteryState_descriptor(), name, value);
}
enum EOSBranch : int {
  EOSBranch_Unknown = 0,
  EOSBranch_Release = 1,
  EOSBranch_ReleaseCandidate = 2,
  EOSBranch_Beta = 3,
  EOSBranch_BetaCandidate = 4,
  EOSBranch_Main = 5,
  EOSBranch_Staging = 6
};
bool EOSBranch_IsValid(int value);
constexpr EOSBranch EOSBranch_MIN = EOSBranch_Unknown;
constexpr EOSBranch EOSBranch_MAX = EOSBranch_Staging;
constexpr int EOSBranch_ARRAYSIZE = EOSBranch_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOSBranch_descriptor();
template<typename T>
inline const std::string& EOSBranch_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EOSBranch>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EOSBranch_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EOSBranch_descriptor(), enum_t_value);
}
inline bool EOSBranch_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EOSBranch* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EOSBranch>(
    EOSBranch_descriptor(), name, value);
}
enum ECommunityItemClass : int {
  ECommunityItemClass_Invalid = 0,
  ECommunityItemClass_Badge = 1,
  ECommunityItemClass_GameCard = 2,
  ECommunityItemClass_ProfileBackground = 3,
  ECommunityItemClass_Emoticon = 4,
  ECommunityItemClass_BoosterPack = 5,
  ECommunityItemClass_Consumable = 6,
  ECommunityItemClass_GameGoo = 7,
  ECommunityItemClass_ProfileModifier = 8,
  ECommunityItemClass_Scene = 9,
  ECommunityItemClass_SalienItem = 10,
  ECommunityItemClass_Sticker = 11,
  ECommunityItemClass_ChatEffect = 12,
  ECommunityItemClass_MiniProfileBackground = 13,
  ECommunityItemClass_AvatarFrame = 14,
  ECommunityItemClass_AnimatedAvatar = 15,
  ECommunityItemClass_SteamDeckKeyboardSkin = 16,
  ECommunityItemClass_SteamDeckStartupMovie = 17
};
bool ECommunityItemClass_IsValid(int value);
constexpr ECommunityItemClass ECommunityItemClass_MIN = ECommunityItemClass_Invalid;
constexpr ECommunityItemClass ECommunityItemClass_MAX = ECommunityItemClass_SteamDeckStartupMovie;
constexpr int ECommunityItemClass_ARRAYSIZE = ECommunityItemClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECommunityItemClass_descriptor();
template<typename T>
inline const std::string& ECommunityItemClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECommunityItemClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECommunityItemClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECommunityItemClass_descriptor(), enum_t_value);
}
inline bool ECommunityItemClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECommunityItemClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECommunityItemClass>(
    ECommunityItemClass_descriptor(), name, value);
}
enum ESteamDeckCompatibilityFeedback : int {
  ESteamDeckCompatibilityFeedbacUnset = 0,
  ESteamDeckCompatibilityFeedbacAgree = 1,
  ESteamDeckCompatibilityFeedbacDisagree = 2,
  ESteamDeckCompatibilityFeedbacIgnore = 3
};
bool ESteamDeckCompatibilityFeedback_IsValid(int value);
constexpr ESteamDeckCompatibilityFeedback ESteamDeckCompatibilityFeedback_MIN = ESteamDeckCompatibilityFeedbacUnset;
constexpr ESteamDeckCompatibilityFeedback ESteamDeckCompatibilityFeedback_MAX = ESteamDeckCompatibilityFeedbacIgnore;
constexpr int ESteamDeckCompatibilityFeedback_ARRAYSIZE = ESteamDeckCompatibilityFeedback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESteamDeckCompatibilityFeedback_descriptor();
template<typename T>
inline const std::string& ESteamDeckCompatibilityFeedback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESteamDeckCompatibilityFeedback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESteamDeckCompatibilityFeedback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESteamDeckCompatibilityFeedback_descriptor(), enum_t_value);
}
inline bool ESteamDeckCompatibilityFeedback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESteamDeckCompatibilityFeedback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESteamDeckCompatibilityFeedback>(
    ESteamDeckCompatibilityFeedback_descriptor(), name, value);
}
enum EProvideDeckFeedbackPreference : int {
  EProvideDeckFeedbackPreference_Unset = 0,
  EProvideDeckFeedbackPreference_Yes = 1,
  EProvideDeckFeedbackPreference_No = 2
};
bool EProvideDeckFeedbackPreference_IsValid(int value);
constexpr EProvideDeckFeedbackPreference EProvideDeckFeedbackPreference_MIN = EProvideDeckFeedbackPreference_Unset;
constexpr EProvideDeckFeedbackPreference EProvideDeckFeedbackPreference_MAX = EProvideDeckFeedbackPreference_No;
constexpr int EProvideDeckFeedbackPreference_ARRAYSIZE = EProvideDeckFeedbackPreference_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EProvideDeckFeedbackPreference_descriptor();
template<typename T>
inline const std::string& EProvideDeckFeedbackPreference_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EProvideDeckFeedbackPreference>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EProvideDeckFeedbackPreference_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EProvideDeckFeedbackPreference_descriptor(), enum_t_value);
}
inline bool EProvideDeckFeedbackPreference_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EProvideDeckFeedbackPreference* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EProvideDeckFeedbackPreference>(
    EProvideDeckFeedbackPreference_descriptor(), name, value);
}
enum ETouchGesture : int {
  ETouchGestureNone = 0,
  ETouchGestureTouch = 1,
  ETouchGestureTap = 2,
  ETouchGestureDoubleTap = 3,
  ETouchGestureShortPress = 4,
  ETouchGestureLongPress = 5,
  ETouchGestureLongTap = 6,
  ETouchGestureTwoFingerTap = 7,
  ETouchGestureTapCancelled = 8,
  ETouchGesturePinchBegin = 9,
  ETouchGesturePinchUpdate = 10,
  ETouchGesturePinchEnd = 11,
  ETouchGestureFlingStart = 12,
  ETouchGestureFlingCancelled = 13
};
bool ETouchGesture_IsValid(int value);
constexpr ETouchGesture ETouchGesture_MIN = ETouchGestureNone;
constexpr ETouchGesture ETouchGesture_MAX = ETouchGestureFlingCancelled;
constexpr int ETouchGesture_ARRAYSIZE = ETouchGesture_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETouchGesture_descriptor();
template<typename T>
inline const std::string& ETouchGesture_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETouchGesture>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETouchGesture_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETouchGesture_descriptor(), enum_t_value);
}
inline bool ETouchGesture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ETouchGesture* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETouchGesture>(
    ETouchGesture_descriptor(), name, value);
}
enum ESessionPersistence : int {
  ESessionPersistence_Invalid = -1,
  ESessionPersistence_Ephemeral = 0,
  ESessionPersistence_Persistent = 1
};
bool ESessionPersistence_IsValid(int value);
constexpr ESessionPersistence ESessionPersistence_MIN = ESessionPersistence_Invalid;
constexpr ESessionPersistence ESessionPersistence_MAX = ESessionPersistence_Persistent;
constexpr int ESessionPersistence_ARRAYSIZE = ESessionPersistence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESessionPersistence_descriptor();
template<typename T>
inline const std::string& ESessionPersistence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESessionPersistence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESessionPersistence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESessionPersistence_descriptor(), enum_t_value);
}
inline bool ESessionPersistence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESessionPersistence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESessionPersistence>(
    ESessionPersistence_descriptor(), name, value);
}
enum ENewSteamAnnouncementState : int {
  ENewSteamAnnouncementState_Invalid = 0,
  ENewSteamAnnouncementState_AllRead = 1,
  ENewSteamAnnouncementState_NewAnnouncement = 2,
  ENewSteamAnnouncementState_FeaturedAnnouncement = 3
};
bool ENewSteamAnnouncementState_IsValid(int value);
constexpr ENewSteamAnnouncementState ENewSteamAnnouncementState_MIN = ENewSteamAnnouncementState_Invalid;
constexpr ENewSteamAnnouncementState ENewSteamAnnouncementState_MAX = ENewSteamAnnouncementState_FeaturedAnnouncement;
constexpr int ENewSteamAnnouncementState_ARRAYSIZE = ENewSteamAnnouncementState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ENewSteamAnnouncementState_descriptor();
template<typename T>
inline const std::string& ENewSteamAnnouncementState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ENewSteamAnnouncementState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ENewSteamAnnouncementState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ENewSteamAnnouncementState_descriptor(), enum_t_value);
}
inline bool ENewSteamAnnouncementState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ENewSteamAnnouncementState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ENewSteamAnnouncementState>(
    ENewSteamAnnouncementState_descriptor(), name, value);
}
enum ECommentThreadType : int {
  ECommentThreadTypeInvalid = 0,
  ECommentThreadTypeScreenshot_Deprecated = 1,
  ECommentThreadTypeWorkshopAccount_Developer = 2,
  ECommentThreadTypeWorkshopAccount_Public = 3,
  ECommentThreadTypePublishedFile_Developer = 4,
  ECommentThreadTypePublishedFile_Public = 5,
  ECommentThreadTypeTest = 6,
  ECommentThreadTypeForumTopic = 7,
  ECommentThreadTypeRecommendation = 8,
  ECommentThreadTypeVideo_Deprecated = 9,
  ECommentThreadTypeProfile = 10,
  ECommentThreadTypeNewsPost = 11,
  ECommentThreadTypeClan = 12,
  ECommentThreadTypeClanAnnouncement = 13,
  ECommentThreadTypeClanEvent = 14,
  ECommentThreadTypeUserStatusPublished = 15,
  ECommentThreadTypeUserReceivedNewGame = 16,
  ECommentThreadTypePublishedFile_Announcement = 17,
  ECommentThreadTypeModeratorMessage = 18,
  ECommentThreadTypeClanCuratedApp = 19,
  ECommentThreadTypeQAndASession = 20,
  ECommentThreadTypeMax = 21
};
bool ECommentThreadType_IsValid(int value);
constexpr ECommentThreadType ECommentThreadType_MIN = ECommentThreadTypeInvalid;
constexpr ECommentThreadType ECommentThreadType_MAX = ECommentThreadTypeMax;
constexpr int ECommentThreadType_ARRAYSIZE = ECommentThreadType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECommentThreadType_descriptor();
template<typename T>
inline const std::string& ECommentThreadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECommentThreadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECommentThreadType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECommentThreadType_descriptor(), enum_t_value);
}
inline bool ECommentThreadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECommentThreadType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECommentThreadType>(
    ECommentThreadType_descriptor(), name, value);
}
enum EBroadcastPermission : int {
  EBroadcastPermissionDisabled = 0,
  EBroadcastPermissionFriendsApprove = 1,
  EBroadcastPermissionFriendsAllowed = 2,
  EBroadcastPermissionPublic = 3,
  EBroadcastPermissionSubscribers = 4
};
bool EBroadcastPermission_IsValid(int value);
constexpr EBroadcastPermission EBroadcastPermission_MIN = EBroadcastPermissionDisabled;
constexpr EBroadcastPermission EBroadcastPermission_MAX = EBroadcastPermissionSubscribers;
constexpr int EBroadcastPermission_ARRAYSIZE = EBroadcastPermission_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBroadcastPermission_descriptor();
template<typename T>
inline const std::string& EBroadcastPermission_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBroadcastPermission>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBroadcastPermission_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBroadcastPermission_descriptor(), enum_t_value);
}
inline bool EBroadcastPermission_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBroadcastPermission* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBroadcastPermission>(
    EBroadcastPermission_descriptor(), name, value);
}
enum EBroadcastEncoderSetting : int {
  EBroadcastEncoderBestQuality = 0,
  EBroadcastEncoderBestPerformance = 1
};
bool EBroadcastEncoderSetting_IsValid(int value);
constexpr EBroadcastEncoderSetting EBroadcastEncoderSetting_MIN = EBroadcastEncoderBestQuality;
constexpr EBroadcastEncoderSetting EBroadcastEncoderSetting_MAX = EBroadcastEncoderBestPerformance;
constexpr int EBroadcastEncoderSetting_ARRAYSIZE = EBroadcastEncoderSetting_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBroadcastEncoderSetting_descriptor();
template<typename T>
inline const std::string& EBroadcastEncoderSetting_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBroadcastEncoderSetting>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBroadcastEncoderSetting_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBroadcastEncoderSetting_descriptor(), enum_t_value);
}
inline bool EBroadcastEncoderSetting_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBroadcastEncoderSetting* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBroadcastEncoderSetting>(
    EBroadcastEncoderSetting_descriptor(), name, value);
}
enum ECloudGamingPlatform : int {
  ECloudGamingPlatformNone = 0,
  ECloudGamingPlatformValve = 1,
  ECloudGamingPlatformNVIDIA = 2
};
bool ECloudGamingPlatform_IsValid(int value);
constexpr ECloudGamingPlatform ECloudGamingPlatform_MIN = ECloudGamingPlatformNone;
constexpr ECloudGamingPlatform ECloudGamingPlatform_MAX = ECloudGamingPlatformNVIDIA;
constexpr int ECloudGamingPlatform_ARRAYSIZE = ECloudGamingPlatform_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECloudGamingPlatform_descriptor();
template<typename T>
inline const std::string& ECloudGamingPlatform_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECloudGamingPlatform>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECloudGamingPlatform_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECloudGamingPlatform_descriptor(), enum_t_value);
}
inline bool ECloudGamingPlatform_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECloudGamingPlatform* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECloudGamingPlatform>(
    ECloudGamingPlatform_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EPublishedFileQueryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPublishedFileQueryType>() {
  return ::EPublishedFileQueryType_descriptor();
}
template <> struct is_proto_enum< ::EPublishedFileInappropriateProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPublishedFileInappropriateProvider>() {
  return ::EPublishedFileInappropriateProvider_descriptor();
}
template <> struct is_proto_enum< ::EPublishedFileInappropriateResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPublishedFileInappropriateResult>() {
  return ::EPublishedFileInappropriateResult_descriptor();
}
template <> struct is_proto_enum< ::EPersonaStateFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPersonaStateFlag>() {
  return ::EPersonaStateFlag_descriptor();
}
template <> struct is_proto_enum< ::EContentCheckProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EContentCheckProvider>() {
  return ::EContentCheckProvider_descriptor();
}
template <> struct is_proto_enum< ::EProfileCustomizationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EProfileCustomizationType>() {
  return ::EProfileCustomizationType_descriptor();
}
template <> struct is_proto_enum< ::EPublishedFileStorageSystem> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPublishedFileStorageSystem>() {
  return ::EPublishedFileStorageSystem_descriptor();
}
template <> struct is_proto_enum< ::ECloudStoragePersistState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECloudStoragePersistState>() {
  return ::ECloudStoragePersistState_descriptor();
}
template <> struct is_proto_enum< ::ESDCardFormatStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESDCardFormatStage>() {
  return ::ESDCardFormatStage_descriptor();
}
template <> struct is_proto_enum< ::EStorageFormatStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStorageFormatStage>() {
  return ::EStorageFormatStage_descriptor();
}
template <> struct is_proto_enum< ::ESystemFanControlMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemFanControlMode>() {
  return ::ESystemFanControlMode_descriptor();
}
template <> struct is_proto_enum< ::EStartupMovieVariant> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStartupMovieVariant>() {
  return ::EStartupMovieVariant_descriptor();
}
template <> struct is_proto_enum< ::EColorGamutLabelSet> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EColorGamutLabelSet>() {
  return ::EColorGamutLabelSet_descriptor();
}
template <> struct is_proto_enum< ::EBluetoothDeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBluetoothDeviceType>() {
  return ::EBluetoothDeviceType_descriptor();
}
template <> struct is_proto_enum< ::ESystemAudioDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemAudioDirection>() {
  return ::ESystemAudioDirection_descriptor();
}
template <> struct is_proto_enum< ::ESystemAudioChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemAudioChannel>() {
  return ::ESystemAudioChannel_descriptor();
}
template <> struct is_proto_enum< ::ESystemAudioPortType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemAudioPortType>() {
  return ::ESystemAudioPortType_descriptor();
}
template <> struct is_proto_enum< ::ESystemAudioPortDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemAudioPortDirection>() {
  return ::ESystemAudioPortDirection_descriptor();
}
template <> struct is_proto_enum< ::ESystemServiceState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemServiceState>() {
  return ::ESystemServiceState_descriptor();
}
template <> struct is_proto_enum< ::EGraphicsPerfOverlayLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EGraphicsPerfOverlayLevel>() {
  return ::EGraphicsPerfOverlayLevel_descriptor();
}
template <> struct is_proto_enum< ::EGPUPerformanceLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EGPUPerformanceLevel>() {
  return ::EGPUPerformanceLevel_descriptor();
}
template <> struct is_proto_enum< ::EScalingFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EScalingFilter>() {
  return ::EScalingFilter_descriptor();
}
template <> struct is_proto_enum< ::ESplitScalingFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESplitScalingFilter>() {
  return ::ESplitScalingFilter_descriptor();
}
template <> struct is_proto_enum< ::ESplitScalingScaler> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESplitScalingScaler>() {
  return ::ESplitScalingScaler_descriptor();
}
template <> struct is_proto_enum< ::EGamescopeBlurMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EGamescopeBlurMode>() {
  return ::EGamescopeBlurMode_descriptor();
}
template <> struct is_proto_enum< ::ESLSHelper> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESLSHelper>() {
  return ::ESLSHelper_descriptor();
}
template <> struct is_proto_enum< ::EHDRVisualization> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EHDRVisualization>() {
  return ::EHDRVisualization_descriptor();
}
template <> struct is_proto_enum< ::EHDRToneMapOperator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EHDRToneMapOperator>() {
  return ::EHDRToneMapOperator_descriptor();
}
template <> struct is_proto_enum< ::ECPUGovernor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECPUGovernor>() {
  return ::ECPUGovernor_descriptor();
}
template <> struct is_proto_enum< ::EUpdaterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EUpdaterType>() {
  return ::EUpdaterType_descriptor();
}
template <> struct is_proto_enum< ::EUpdaterState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EUpdaterState>() {
  return ::EUpdaterState_descriptor();
}
template <> struct is_proto_enum< ::EStorageBlockContentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStorageBlockContentType>() {
  return ::EStorageBlockContentType_descriptor();
}
template <> struct is_proto_enum< ::EStorageBlockFileSystemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStorageBlockFileSystemType>() {
  return ::EStorageBlockFileSystemType_descriptor();
}
template <> struct is_proto_enum< ::EStorageDriveMediaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStorageDriveMediaType>() {
  return ::EStorageDriveMediaType_descriptor();
}
template <> struct is_proto_enum< ::ESystemDisplayCompatibilityMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemDisplayCompatibilityMode>() {
  return ::ESystemDisplayCompatibilityMode_descriptor();
}
template <> struct is_proto_enum< ::ESteamDeckCompatibilityCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESteamDeckCompatibilityCategory>() {
  return ::ESteamDeckCompatibilityCategory_descriptor();
}
template <> struct is_proto_enum< ::ESteamDeckCompatibilityResultDisplayType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESteamDeckCompatibilityResultDisplayType>() {
  return ::ESteamDeckCompatibilityResultDisplayType_descriptor();
}
template <> struct is_proto_enum< ::EACState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EACState>() {
  return ::EACState_descriptor();
}
template <> struct is_proto_enum< ::EBatteryState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBatteryState>() {
  return ::EBatteryState_descriptor();
}
template <> struct is_proto_enum< ::EOSBranch> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EOSBranch>() {
  return ::EOSBranch_descriptor();
}
template <> struct is_proto_enum< ::ECommunityItemClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECommunityItemClass>() {
  return ::ECommunityItemClass_descriptor();
}
template <> struct is_proto_enum< ::ESteamDeckCompatibilityFeedback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESteamDeckCompatibilityFeedback>() {
  return ::ESteamDeckCompatibilityFeedback_descriptor();
}
template <> struct is_proto_enum< ::EProvideDeckFeedbackPreference> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EProvideDeckFeedbackPreference>() {
  return ::EProvideDeckFeedbackPreference_descriptor();
}
template <> struct is_proto_enum< ::ETouchGesture> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETouchGesture>() {
  return ::ETouchGesture_descriptor();
}
template <> struct is_proto_enum< ::ESessionPersistence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESessionPersistence>() {
  return ::ESessionPersistence_descriptor();
}
template <> struct is_proto_enum< ::ENewSteamAnnouncementState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ENewSteamAnnouncementState>() {
  return ::ENewSteamAnnouncementState_descriptor();
}
template <> struct is_proto_enum< ::ECommentThreadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECommentThreadType>() {
  return ::ECommentThreadType_descriptor();
}
template <> struct is_proto_enum< ::EBroadcastPermission> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBroadcastPermission>() {
  return ::EBroadcastPermission_descriptor();
}
template <> struct is_proto_enum< ::EBroadcastEncoderSetting> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBroadcastEncoderSetting>() {
  return ::EBroadcastEncoderSetting_descriptor();
}
template <> struct is_proto_enum< ::ECloudGamingPlatform> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECloudGamingPlatform>() {
  return ::ECloudGamingPlatform_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_enums_2eproto
